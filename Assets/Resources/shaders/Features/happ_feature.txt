// Hybrid aparent ridges Object POSTPROCESSING 
// Required:
//	_InterpolatedNormalsBuffer
//	_PrincipalCurvatureBuffer
//
//	_happ_TauFactor

#if !((IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_PIXEL ) || (IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_VERTEX ))
#error "Hybrid apaprent ridges pp can only be detected in pixel or vertex"
#endif

#if  (IN_happ_FEATURE_APPLY_MODE != APPLY_MODE_FILLING )
#error "hybrid apparent ridges pp can only be applied by filling"
#endif



// algorithm-native functions


			struct happ_HybridApparentRidgesStage1Output {
				float q1;
				float3 w1;
			};

			struct happ_HybridApparentRidgesStage1Input{
				float3 vertexWorldPos;
				float3 objectNrm;
				PrincipalCurvatureInfo curvatureInfo;
			};

			happ_HybridApparentRidgesStage1Output happ_CalculateHybridApparentRidges(happ_HybridApparentRidgesStage1Input input) {
				float3 vertexWorldPos = input.vertexWorldPos;
				float3 objectNrm = input.objectNrm;

				float3 worldNrm = normalize(mul((float3x3)unity_ObjectToWorld, normalize(objectNrm)));
				float3 viewDir =normalize( vertexWorldPos -  UNITY_MATRIX_IT_MV[2].xyz);
				float ndotv = dot(worldNrm,viewDir);

				float u = dot(viewDir, (input.curvatureInfo.direction1));
				float v = dot(viewDir, (input.curvatureInfo.direction2));
				float uv = u*v;
				float u2 = u * u;
				float v2 = v*v;
				float csc2theta = 1 / (u2 + v2);
				float secthetaminus1 = 1 /abs(ndotv) - 1;

				float2x2 P_1;
				P_1[0][0] = (1.0 + secthetaminus1*csc2theta*u2);
				P_1[0][1] = (secthetaminus1*csc2theta*uv);
				P_1[1][0] = (secthetaminus1*csc2theta*uv);
				P_1[1][1] = (1.0 + secthetaminus1*csc2theta*v2);

				float2x2 S;
				S[0][0] = input.curvatureInfo.value1;
				S[0][1] = 0;
				S[1][0] = 0;
				S[1][1] = input.curvatureInfo.value2;

				float2x2 Q = mul(S, P_1);

				float2x2 QTQ = mul(transpose(Q), Q);

				float disc = sqrt(pow(QTQ[0][0] * QTQ[1][1], 2) + 4 * pow(QTQ[0][1], 2)) / 2;

				float lambda1 = (QTQ[0][0] + QTQ[1][1]) / 2 + disc;
				float lambda2 = (QTQ[0][0] + QTQ[1][1]) / 2 - disc;
				float q1;
				if (abs(lambda1) >= abs(lambda2)) {
					q1 = lambda1;
				}
				else {
					q1 = lambda2;
				}

				float2 s1 = normalize(float2(Q[1][1] - q1, -Q[0][1]));
				float3 w1 = s1[0] * input.curvatureInfo.direction1 + s1[1] * input.curvatureInfo.direction2;

				happ_HybridApparentRidgesStage1Output stage1Result;
				
				stage1Result.w1 = w1;
				stage1Result.q1 = q1;

				return stage1Result;
			}

			float3 happ_PackStage1Result(happ_HybridApparentRidgesStage1Output stage1Result) {
				float2 t1;
				if (stage1Result.w1.z >= 0) {
					t1 = normalize(-stage1Result.w1.xy);
				}
				else {
					t1 = normalize(stage1Result.w1.xy);
				}
				t1 = (t1 + 1) / 2;
				return float3(pow(2, _happ_TauFactor)*stage1Result.q1, t1);
			}

struct happ_VertexOutBuffer{
	#if IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_VERTEX
		happ_HybridApparentRidgesStage1Output buf;
	#elif IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_PIXEL
		happ_HybridApparentRidgesStage1Input buf;
	#endif
};
#define	Transfer_happ_VertexOutBuffer 1

happ_VertexOutBuffer happ_VertexFilter(VertexSituation situation, appdata v) {

	float3 vertexWorldPos = mul(unity_ObjectToWorld, v.pos);
	float3 objectNrm = _InterpolatedNormalsBuffer[situation.vid];

	PrincipalCurvatureInfo info = _PrincipalCurvatureBuffer[situation.vid];

	happ_HybridApparentRidgesStage1Input stage1Input;
	stage1Input.vertexWorldPos = vertexWorldPos;
	stage1Input.objectNrm = objectNrm;
	stage1Input.curvatureInfo = info;


	happ_VertexOutBuffer buffer;
#if IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_VERTEX
	happ_HybridApparentRidgesStage1Output stage1Output = happ_CalculateHybridApparentRidges(stage1Input);
	buffer.buf = stage1Output;
#elif IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_PIXEL
	buffer.buf = stage1Input;
#endif

	return buffer;
}

//////////// GEOMETRY SHADER
struct happ_GeometryOutBuffer {
	#if IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_VERTEX
		happ_HybridApparentRidgesStage1Output buf;
	#elif IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_PIXEL
		happ_HybridApparentRidgesStage1Input buf;
	#endif
};
#define	Transfer_happ_GeometryOutBuffer 1


void happ_GeometryFilter(happ_VertexOutBuffer inBuffer[3], inout happ_GeometryOutBuffer outBuffer[3], geometry_edge_situation s, geometry_camera_situation camera_situation, uint triangleIndex, inout bool shouldCreateFins, inout happ_GeometryOutBuffer finBuffer){
	outBuffer[triangleIndex] = inBuffer[triangleIndex];
	finBuffer = outBuffer[triangleIndex];
}

////////////////////// PIXEL SHADER

#if IN_USE_GEOMETRY_SHADER
	#define happ_FragmentInBuffer happ_GeometryOutBuffer
#else
	#define happ_FragmentInBuffer happ_VertexOutBuffer
#endif

void happ_FragmentSurfaceLineFilter(FragmentSurfaceLineSituation situation, happ_FragmentInBuffer scIn, inout float4 color) {
}

void happ_FragmentFinFilter( happ_FragmentInBuffer scIn, inout float4 color) {
}

void happ_FragmentFillingFilter(happ_FragmentInBuffer buffer, inout float4 color){

#if IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_VERTEX
	color.rgb = happ_PackStage1Result(CalculateHybridApparentRidges(buffer.buf));
#elif IN_happ_FEATURE_DETECTION_MODE == DETECTION_MODE_PIXEL
	color.rgb = happ_PackStage1Result( happ_CalculateHybridApparentRidges(buffer.buf));
#endif
}
